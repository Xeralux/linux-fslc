/*
 * Definitions specific to the i.MX6DL version of the Medianode.
 *
 * Copyright (C) 2013 Sensity Systems, Inc.
 *
 * CONFIDENTIAL AND PROPRIETARY.
 */

/dts-v1/;

#include "imx6dl.dtsi"
#include "imx6qdl-sensity_medianode.dtsi"

/ {
	model = "Sensity Systems Medianode (MX6DL)";
	compatible = "sensity,medianode", "fsl,imx6dl";

	regulators {
		compatible = "simple-bus";

		camboard_ch0_fixed_5v0: camboard-ch0-fixed-5v0 {
			compatible = "regulator-fixed";
			regulator-name = "camboard-ch0-fixed-5v0";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&camboard_gpio 2 0>;
			gpio-open-drain;
			enable-active-high;
			regulator-boot-on;
		};

		camboard_ch1_fixed_5v0: camboard-ch1-fixed-5v0 {
			compatible = "regulator-fixed";
			regulator-name = "camboard-ch1-fixed-5v0";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			gpio = <&camboard_gpio 3 0>;
			gpio-open-drain;
			enable-active-high;
			regulator-boot-on;
		};
	};

	camboard_ch0_reset: camboard-ch0-reset {
		compatible = "gpio-reset";
		reset-gpios = <&camboard_gpio 0 GPIO_ACTIVE_LOW>;
		reset-delay-us = <500000>;
		#reset-cells = <0>;
		gpio-open-drain;
		sleep-ok;
	};

	camboard_ch0_ap0100_reset: camboard-ch0-ap0100-reset {
		compatible = "gpio-reset";
		reset-gpios = <&max927x_ch0 5 GPIO_ACTIVE_LOW>;
		reset-delay-us = <1100000>;
		#reset-cells = <0>;
		gpio-open-drain;
		sleep-ok;
	};


	camboard_ch1_reset: camboard-ch1-reset {
		compatible = "gpio-reset";
		reset-gpios = <&camboard_gpio 1 GPIO_ACTIVE_LOW>;
		reset-delay-us = <500000>;
		#reset-cells = <0>;
		gpio-open-drain;
		sleep-ok;
	};

	camboard_ch1_ap0100_reset: camboard-ch1-ap0100-reset {
		compatible = "gpio-reset";
		reset-gpios = <&max927x_ch1 5 GPIO_ACTIVE_LOW>;
		reset-delay-us = <1100000>;
		#reset-cells = <0>;
		gpio-open-drain;
		sleep-ok;
	};
	
	camera_ch1 {
		compatible = "fsl,v4l2-subdev-pipeline";
		mxc-node = <&ssmn_mipi>;
	};

	/* Camera driver on MIPI interface */
	ssmn_mipi: mxc_mipi_ch1 {
		compatible = "fsl,mxc-subdev-mipi";
		clocks = <&clks 201>;
		clock-names = "csi_mclk";
		csi_id = <1>;
		mclk = <24000000>;
		mclk_source = <0>;
		gpr = <&gpr>;
		
		port {
			mxc_mipi_1_endpoint: endpoint {
				remote-endpoint = <&tc35874x_ch1_mipi>;
				/*data-lanes = <0 1>; ?*/
				/*clock-lanes = <0>; ?*/
			};
		};
	};

	camera_ch0 {
		compatible = "fsl,v4l2-subdev-pipeline";
		mxc-node = <&ssmn_parallel>;
	};

	ssmn_parallel: mxc_parallel_ch0 {
		compatible = "fsl,mxc-subdev-parallel";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_ipu1_2_mn>;
		clocks = <&clks 201>;
		clock-names = "csi_mclk";
		csi_id = <0>;
		mclk = <24000000>;
		mclk_source = <0>;
		gpr = <&gpr>;

		port {
			/*lines commented out need to be confirmed*/
			mxc_parallel_0_endpoint: endpoint {
			remote-endpoint = <&tc35874x_mn_parallel>;
				bus-width = <10>; /*technically true but only 8 are used now*/
				data-shift = <0>;
				/*hsync-active = <0>; ?*/
				/*vsync-active = <0>; ?*/
				/*pclk-sample = <0>; ?*/
			};
		};
	};
};

&i2c1 {
	/*  Toshiba MIPI bridge 0 on parallel interface: CPLBTX->CPLBRX(MIPI-Rx Parallel-Tx) */
	mipi_to_parallel_mn: mn-tc35874x@0e {
		compatible = "toshiba,tc35874x";
		reg = <0x0e>;
		output-mode = "parallel";

		ports {
		#address-cells = <1>;
		#size-cells = <0>;
			port@0 {
				/*lines commented out need to be confirmed*/
				tc35874x_mn_parallel: endpoint {
					remote-endpoint = <&mxc_parallel_0_endpoint>;
					bus-width = <10>; /*technically true but only 8 are used now*/
					data-shift = <0>;
					/*hsync-active = <0>; ?*/
					/*vsync-active = <0>; ?*/
					/*pclk-sample = <0>; ?*/
				};
			};
			port@1 {
				tc35874x_mn_mipi: endpoint {
					remote-endpoint = <&tc35874x_ch0_mipi>;
					/*data-lanes = <0 1>; ?*/
					/*clock-lanes = <0>; ?*/
				};
			};
		};
	};
};

&i2c2 {
	/* mxc_hdmi_i2c is inoperative because it needs to use the i2c mux.
	 	However, moving mxc_hdmi_i2c to the mux appears to cause problems
	 	with the other freescale drivers.  There are default values used
	 	if the EDID can't be read which is why it still works.
	 */
	mxc_hdmi_i2c@50 {
		compatible = "fsl,mxc_hdmi_i2c";
		reg = <0x50>;
	};

	/* PCA9546 I2C multiplexer */
	i2cmux@70 {
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "nxp,pca9546";
		reg = <0x70>;
		/*DO NOT ADD nxp,deselect-on-exit as this will break
		 *code which expects the mux to be selected across an entire
		 *i2c transaction
		*/
	    i2c5: i2c@0 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "nxp,pca954x-bus";
			reg = <0>;
			nr = <4>;
		};
		i2c6: i2c@1 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "nxp,pca954x-bus";
			reg = <1>;
			nr = <5>;
		};
		i2c7: i2c@2 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "nxp,pca954x-bus";
			reg = <2>;
			nr = <6>;
		};
		i2c8: i2c@3 {
			#address-cells = <1>;
			#size-cells = <0>;
			compatible = "nxp,pca954x-bus";
			reg = <3>;
			nr = <7>;
		};
	};

	/* PCA9557 I/O expander */
	camboard_gpio: io_expander@18 {
		compatible = "nxp,pca9557";
		gpio-controller;
		#gpio-cells = <2>;
		gpio_base = <248>;	/* /sys/kernel/debug/gpio */
		reg = <0x18>;
	};

};


&i2c4 {
	/*
	 * All signals go out on connectors J19 external sensor bus
	 * and J24 audio pod.
	 */
	clock-frequency = <400000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c4_1>;	/*  "ENET TX" pins.  */
	status = "okay";

};

&i2c5 {

	max927x_ch0: camboard-ch0-max927x@48 {
		compatible = "maxim,max927x";
		resets = <&camboard_ch0_reset>;
		reg = <0x48>;
		remote-reg = <0x40>;
		slave-supply = <&camboard_ch0_fixed_5v0>;
		slave-on-delay-ms = <1100>;
		/*The voltage goes from about 5V to 1.125V after 2s*/
		/*Longer does not really help*/
		slave-off-delay-ms = <2000>;
		/*REVTXAMP REV_TRF REV_LOGAIN I2C_SLVSH I2C_MSTBT*/
		cfg-0 = <3 2 0 3 4>;

		#address-cells = <1>;
		#size-cells = <0>;
		i2c-nr = <8>;

		gpio-controller;
		#gpio-cells = <2>;

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				max927x_ch0_deserializer: endpoint {
					remote-endpoint = <&tc35874x_ch0_parallel>;
					bus-width = <10>; /*technically true but only 8 are used now*/
					data-shift = <0>;
					/*hsync-active = <0>; ?*/
					/*vsync-active = <0>; ?*/
					/*pclk-sample = <0>; ?*/
				};
			};

			port@1 {
				max927x_ch0_serializer_1: endpoint {
					remote-endpoint = <&ap0100_ch0_endpoint>;
					bus-width = <10>; /*technically true but only 8 are used now*/
					data-shift = <0>;
					hsync-active = <0>;
					vsync-active = <0>;
					pclk-sample = <0>;
				};
			};

			port@2 {
				max927x_ch0_serializer_2: endpoint {
					remote-endpoint = <&adv7611_ch0_endpoint>;
					bus-width = <8>;
					data-shift = <0>;
					hsync-active = <0>;
					vsync-active = <0>;
					pclk-sample = <0>;
				};
			};
		};

		i2c9: i2c@0 {
			#address-cells = <1>;
			#size-cells = <0>;
			i2c;

			ap0100_ch0: camboard-ch0-ap0100@5d {
				compatible = "aptina,ap0100_m034";
				resets = <&camboard_ch0_ap0100_reset>;
				reg = <0x5d>;

				port {
					ap0100_ch0_endpoint: endpoint {
						remote-endpoint = <&max927x_ch0_serializer_1>;
						bus-width = <10>; /*technically true but only 8 are used now*/
						data-shift = <0>;
						/*hsync-active = <0>; ?*/
						/*vsync-active = <0>; ?*/
						/*pclk-sample = <0>; ?*/
					};
				};
			};

			adv7611_ch0: camboard-ch0-adv7611@4c {
				compatible = "adi,adv7611";
				reg = <0x4c>;
				reg-avlink = <0x60>;
				reg-cec = <0x61>;
				reg-infoframe = <0x62>;
				reg-esdp = <0x63>;
				reg-dpp = <0x64>;
				reg-afe = <0x65>;
				reg-rep = <0x66>;
				reg-edid = <0x67>;
				reg-hdmi = <0x68>;
				reg-test = <0x69>;
				reg-cp = <0x6a>;
				reg-vdp = <0x6b>;
				default-input = <0>;

				ports {
					#address-cells = <1>;
					#size-cells = <0>;
/*
					hdmi_ch0: port@0 {
						reg = <0>;
					};
*/
					port@1 {
						reg = <1>;
						adv7611_ch0_endpoint: endpoint {
							remote-endpoint = <&max927x_ch0_serializer_2>;
							bus-width = <8>;
							data-shift = <0>;
							hsync-active = <0>;
							vsync-active = <0>;
							pclk-sample = <0>;
						};
					};
				};
			};

			/*HACK tc bridge is a child here because it shares a reset with max927x*/
			/*  Toshiba MIPI bridge 1 on MIPI interface/channel: Parallel-Rx MIPI-Tx */
			parallel_to_mipi_ch0: camboard-ch0-tc35874x@0e {
				compatible = "toshiba,tc35874x";
				reg = <0x0e>;
				output-mode = "mipi";

				ports {
					#address-cells = <1>;
					#size-cells = <0>;
					port@0 {
						tc35874x_ch0_mipi: endpoint {
							remote-endpoint = <&tc35874x_mn_mipi>;
							/*data-lanes = <0 1>; ?*/
							/*clock-lanes = <0>; ?*/
						};
					};
					port@1 {
						/*lines commented out need to be confirmed*/
						tc35874x_ch0_parallel: endpoint {
							remote-endpoint = <&max927x_ch0_deserializer>;
							bus-width = <10>; /*technically true but only 8 are used now*/
							data-shift = <0>;
							/*hsync-active = <0>; ?*/
							/*vsync-active = <0>; ?*/
							/*pclk-sample = <0>; ?*/
						};
					};
				};
			};
		};
	};
	
};

&i2c6 {	
	max927x_ch1: camboard-ch1-max927x@48 {
		compatible = "maxim,max927x";
		resets = <&camboard_ch1_reset>;
		reg = <0x48>;
		remote-reg = <0x40>;
		slave-supply = <&camboard_ch1_fixed_5v0>;
		slave-on-delay-ms = <1100>;
		/*The voltage goes from about 5V to 1.125V after 2s*/
		/*Longer does not really help*/
		slave-off-delay-ms = <2000>;
		/*REVTXAMP REV_TRF REV_LOGAIN I2C_SLVSH I2C_MSTBT*/
		cfg-0 = <3 2 0 3 4>;

		#address-cells = <1>;
		#size-cells = <0>;
		i2c-nr = <9>;

		gpio-controller;
		#gpio-cells = <2>;

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				max927x_ch1_deserializer: endpoint {
					remote-endpoint = <&tc35874x_ch1_parallel>;
					bus-width = <10>; /*technically true but only 8 are used now*/
					data-shift = <0>;
					/*hsync-active = <0>; ?*/
					/*vsync-active = <0>; ?*/
					/*pclk-sample = <0>; ?*/
				};
			};

			port@1 {
				max927x_ch1_serializer_1: endpoint {
					remote-endpoint = <&ap0100_ch1_endpoint>;
					bus-width = <10>; /*technically true but only 8 are used now*/
					data-shift = <0>;
					/*hsync-active = <0>; ?*/
					/*vsync-active = <0>; ?*/
					/*pclk-sample = <0>; ?*/
				};
			};

			port@2 {
				max927x_ch1_serializer_2: endpoint {
					remote-endpoint = <&adv7611_ch1_endpoint>;
					bus-width = <8>; /*technically true but only 8 are used now*/
					data-shift = <0>;
					/*hsync-active = <0>; ?*/
					/*vsync-active = <0>; ?*/
					/*pclk-sample = <0>; ?*/
				};
			};
		};

		i2c10: i2c@0 {
			#address-cells = <1>;
			#size-cells = <0>;
			i2c;

			ap0100_ch1: camboard-ch1-ap0100@5d {
				compatible = "aptina,ap0100_m034";
				resets = <&camboard_ch1_ap0100_reset>;
				reg = <0x5d>;
				
				port {
					ap0100_ch1_endpoint: endpoint {
						remote-endpoint = <&max927x_ch1_serializer_1>;
						bus-width = <10>; /*technically true but only 8 are used now*/
						data-shift = <0>;
						/*hsync-active = <0>; ?*/
						/*vsync-active = <0>; ?*/
						/*pclk-sample = <0>; ?*/
					};
				};
			};

			adv7611_ch1: camboard-ch1-adv7611@4c {
				compatible = "adi,adv7611";
				reg = <0x4c>;
				reg-avlink = <0x60>;
				reg-cec = <0x61>;
				reg-infoframe = <0x62>;
				reg-esdp = <0x63>;
				reg-dpp = <0x64>;
				reg-afe = <0x65>;
				reg-rep = <0x66>;
				reg-edid = <0x67>;
				reg-hdmi = <0x68>;
				reg-test = <0x69>;
				reg-cp = <0x6a>;
				reg-vdp = <0x6b>;
				default-input = <0>;

				ports {
					#address-cells = <1>;
					#size-cells = <0>;
/*
					hdmi_ch0: port@0 {
						reg = <0>;
					};
*/
					port@1 {
						reg = <1>;
						adv7611_ch1_endpoint: endpoint {
							remote-endpoint = <&max927x_ch1_serializer_2>;
							bus-width = <8>;
							data-shift = <0>;
							hsync-active = <0>;
							vsync-active = <0>;
							pclk-sample = <0>;
						};
					};
				};
			};

			/*HACK tc bridge is a child here because it shares a reset with max927x*/
			/*  Toshiba MIPI bridge 1 on MIPI interface/channel: Parallel-Rx MIPI-Tx */
			parallel_to_mipi_ch1: camboard-ch1-tc35874x@0e {
				compatible = "toshiba,tc35874x";
				reg = <0x0e>;
				output-mode = "mipi";
				#address-cells = <1>;
				#size-cells = <0>;
				ports {
					port@0 {
						tc35874x_ch1_mipi: endpoint {
							remote-endpoint = <&mxc_mipi_1_endpoint>;
							/*data-lanes = <0 1>; ?*/ 
							/*clock-lanes = <0>; ?*/
						};
					};
					port@1 {
						/*lines commented out need to be confirmed*/
						tc35874x_ch1_parallel: endpoint {
							remote-endpoint = <&max927x_ch1_deserializer>;
							bus-width = <10>; /*technically true but only 8 are used now*/
							data-shift = <0>;
							/*hsync-active = <0>; ?*/
							/*vsync-active = <0>; ?*/
							/*pclk-sample = <0>; ?*/
						};
					};
				};
			};
		};
	};
};

&i2c8 {
	/*https://github.com/analogdevicesinc/linux/blob/adau17x1/sound/soc/codecs/adau1761.c*/
	adau1761@3b {
		compatible = "adau1761";
		reg = <0x3b>;
	};
};
